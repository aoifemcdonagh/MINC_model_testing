import caffe
import sys
import skimage

from material_segmentation import segment as resize, minc_plotting as minc_plot, minc_classify as minc_utils
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.image as mpimg

SCALES = [1.0/np.sqrt(2), 1.0, np.sqrt(2)]  # Define scales as per MINC paper

def upsample(im):
    """
    Function for performing upscaling of probability maps generated by MINC model
    :return: scaled, upsampled and averaged probability maps for all classes
    """

    resized_images = resize.resize_images(im)  # perform image resizing
    outputs = [minc_utils.classify(image) for image in resized_images]  # Perform classification on images
    prob_maps = [minc_utils.get_probability_maps(out) for out in outputs]  # Get probability maps for each class for each image

    # Upsampling probability maps to be same dimensions as original image (plus padding)
    upsampled_prob_maps = np.array([[skimage.transform.resize(prob_map,
                                                                  output_shape=(im.shape[0], im.shape[1]),
                                                                  mode='constant',
                                                                  cval=0,
                                                                  preserve_range=True)
                                         for prob_map in prob_maps_single_image]
                                        for prob_maps_single_image in prob_maps])

    # Probability maps for each class, averaged from resized images probability maps
    averaged_prob_maps = np.average(upsampled_prob_maps, axis=0)

    return averaged_prob_maps


def plot_simple(im, data):
    """
    Function to plot the input image and data side by side.
    :param im: input image
    :param data: a result from classification
    :return:
    """

    fig, axs = plt.subplots(ncols=2, figsize=(30, 10))
    fig.subplots_adjust(hspace=0.5, left=0.07, right=0.93)
    ax = axs[0]
    hb = ax.imshow(mpimg.imread(im))
    ax.set_title("Input image")

    ax = axs[1]
    hb = ax.imshow(data)
    ax.set_title("data/result")
    cb = fig.colorbar(hb, ax=ax)

    plt.show()


def add_padding(im, pad):
    """
    Function for padding image before classification
    :param im: image (preloaded with caffe.io.load_image)
    :return: image with padding
    """

    return np.pad(im, pad_width=((pad, pad), (pad, pad), (0, 0)), mode='symmetric')


def remove_padding(im, pad):
    """
    Function for removing padding from an image
    :param im: image to remove padding from
    :param pad: number of pixels of padding to remove
    :return:
    """

    return im[pad:-pad, pad:-pad]


if __name__ == "__main__":
    caffe.set_mode_gpu()
    image_path = sys.argv[1]  # path to image to be segmented
    padding = int(sys.argv[2])  # number of pixels to pad
    image = caffe.io.load_image(image_path)  # Must load images with this method!
    #image = add_padding(image, padding)  # add padding

    av_prob_maps = upsample(image)

    confidence_map = av_prob_maps.max(axis=0)
    plot_simple(image_path, confidence_map)

    minc_plot.plot_class_map(av_prob_maps)




