import caffe
import sys
import os
import skimage

import full_image_classify as minc_utils
import classify_resized as resize
from scipy import misc
import numpy as np
from datetime import datetime

SCALES = [1.0/np.sqrt(2), 1.0, np.sqrt(2)]  # Define scales as per MINC paper

def upsample(im_path):
    """
    Function for performing upscaling of probability maps generated by MINC model
    :return:
    """

    im_files = resize.resize_image(im_path)  # perform image resizing
    outputs = [minc_utils.classify(image) for image in im_files]  # Perform classification on images
    prob_maps = [minc_utils.get_probability_maps(out) for out in outputs]  # Get probability maps for each class for each image

    # Resize probability maps so that they are the same size as original image
    for i in range(0, len(prob_maps)):
        prob_maps_single_scale = prob_maps[i]
        for j in range(0, len(prob_maps_single_scale)):
            prob_map = prob_maps_single_scale[j]
            #upsampled_prob_maps_ski[i][j] = skimage.transform.rescale(prob_map, scale=(1/SCALES[i]))


def upsample_bilinear(im_path):
    """
    Use model with BilinearFiller blob
    :return:
    """

    im_files = resize.resize_image(im_path)  # perform image resizing
    outputs = [minc_utils.classify(image,
                                   prototxt="models/deploy-googlenet-conv-upsample.prototxt",
                                   caffemodel="models/minc-googlenet-conv-upsample.caffemodel")
               for image in im_files]  # Perform classification on images

    prob_maps = [minc_utils.get_probability_maps(out) for out in outputs]  # Get probability maps for each class for each image

if __name__ == "__main__":
    caffe.set_mode_gpu()
    image_path = sys.argv[1]  # path to image to be segmented
    upsample(image_path)

